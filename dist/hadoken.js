(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Hadoken"] = factory();
	else
		root["Hadoken"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Adapters/Gamepad.ts":
/*!*********************************!*\
  !*** ./src/Adapters/Gamepad.ts ***!
  \*********************************/
/*! exports provided: Hadoken, isStick, isTrigger, isDigital */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hadoken\", function() { return Hadoken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStick\", function() { return isStick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isTrigger\", function() { return isTrigger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDigital\", function() { return isDigital; });\n/* harmony import */ var ph_Hadoken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ph/Hadoken */ \"./src/Hadoken.ts\");\n/* harmony import */ var ph_Common_Gamepad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ph/Common/Gamepad */ \"./src/Common/Gamepad.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\n/**\r\n * Hadoken implementation to support receiving inputs from gamepads.\r\n */\r\nvar Hadoken = /** @class */ (function (_super) {\r\n    __extends(Hadoken, _super);\r\n    /**\r\n     *\r\n     * @param scn {Phaser.Scene} the scene this input manager belongs in\r\n     * @param cfg {GamepadHadokenConfig}\r\n     */\r\n    function Hadoken(scn, cfg) {\r\n        var _this = this;\r\n        var data = { stick: {}, trigger: {} };\r\n        _this = _super.call(this, scn, cfg, mkControllerSync(data)) || this;\r\n        _this.analogData = data;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns true or false if we can determine that the wrapped gamepad\r\n     * supports the standard gamepad mapping used by StandardButtons and\r\n     * specified in https://w3c.github.io/gamepad/#remapping.\r\n     *\r\n     * If we're unable to be certain that the standard mapping is (or is not)\r\n     * supported then null is returned.\r\n     */\r\n    Hadoken.prototype.isStandardMapping = function () {\r\n        return Object(ph_Common_Gamepad__WEBPACK_IMPORTED_MODULE_1__[\"isStandardMapping\"])(this.hadokenData.config.gamepad);\r\n    };\r\n    return Hadoken;\r\n}(ph_Hadoken__WEBPACK_IMPORTED_MODULE_0__[\"Hadoken\"]));\r\n\r\nfunction isStick(b) { return b.type === 'stick'; }\r\nfunction isTrigger(b) { return b.type === 'trigger'; }\r\nfunction isDigital(b) { return b.type === 'digital'; }\r\n// mkControllerSync produces a function that will check a controller state\r\n// and send updates back to the hadoken context. Additionally it reports\r\n// analog state back into the provided data object which is queryable from\r\n// a Gamepad.Hadoken\r\nfunction mkControllerSync(data) {\r\n    return function (ctx) {\r\n        var cfg = ctx.config;\r\n        var pad = cfg.gamepad;\r\n        // aggregate all pressed/notpressed then apply a single update\r\n        var _a = cfg.buttonMap.reduce(function (acc, def) {\r\n            if (isStick(def)) {\r\n                if (pad.axes.length > Math.max(def.verticalAxis.idx, def.horizontalAxis.idx)) {\r\n                    var angle = getStickAngle(def, pad);\r\n                    var value = getStickMagnitude(def, pad);\r\n                    data.stick[def.name] = { angle: angle, value: value };\r\n                    var mapping_1 = def.angleMapper(angle, value);\r\n                    var unmappedKeys = def.allMapped.filter(function (k) { return mapping_1 === null || k !== mapping_1; });\r\n                    return [\r\n                        acc[0].concat((mapping_1 !== null ? [mapping_1] : [])),\r\n                        acc[1].concat(unmappedKeys),\r\n                    ];\r\n                }\r\n                else {\r\n                    data.stick[def.name] = { angle: 0, value: 0 };\r\n                    return [acc[0], acc[1].concat(def.allMapped)];\r\n                }\r\n            }\r\n            if (isTrigger(def)) {\r\n                if (pad.buttons.length > def.idx) {\r\n                    var value = pad.buttons[def.idx].value || 0;\r\n                    data.trigger[def.name] = value;\r\n                    var mapping_2 = def.triggerMapper(value);\r\n                    var unmappedKeys = def.allMapped.filter(function (k) { return mapping_2 === null || k !== mapping_2; });\r\n                    return [\r\n                        acc[0].concat((mapping_2 !== null ? [mapping_2] : [])),\r\n                        acc[1].concat(unmappedKeys),\r\n                    ];\r\n                }\r\n                else {\r\n                    data.trigger[def.name] = 0;\r\n                    return [acc[0], acc[1].concat(def.allMapped)];\r\n                }\r\n            }\r\n            if (isDigital(def)) {\r\n                if (pad.buttons.length > def.idx) {\r\n                    var pressed_1 = pad.buttons[def.idx].pressed;\r\n                    if (pressed_1) {\r\n                        return [acc[0].concat([def.mapping]), acc[1]];\r\n                    }\r\n                    else {\r\n                        return [acc[0], acc[1].concat([def.mapping])];\r\n                    }\r\n                }\r\n            }\r\n            console.error(\"Unhandled button definition: \" + JSON.stringify(def));\r\n            return acc;\r\n        }, [[], []]), pressed = _a[0], notPressed = _a[1];\r\n        Object(ph_Hadoken__WEBPACK_IMPORTED_MODULE_0__[\"MaybeBatchUpdate\"])(ctx, pressed, notPressed, pad.timestamp);\r\n    };\r\n}\r\nfunction clamp(n, min, max) {\r\n    return Math.min(Math.max(n, min), max);\r\n}\r\nfunction getStickAngle(def, pad) {\r\n    var vAxis = pad.axes[def.verticalAxis.idx];\r\n    var hAxis = pad.axes[def.horizontalAxis.idx];\r\n    var xVal = hAxis.value * def.horizontalAxis.right;\r\n    var yVal = vAxis.value * def.verticalAxis.up * -1;\r\n    var deg = Math.atan(yVal / xVal) * 57.295827;\r\n    // quad 2 / 3\r\n    if (xVal < 0) {\r\n        deg = 180 + deg;\r\n    }\r\n    if (deg < 0) {\r\n        deg += 360;\r\n    }\r\n    if (deg >= 360) {\r\n        deg -= 360;\r\n    }\r\n    // TODO: need to test w/ other controllers that have different axis mappings\r\n    return deg;\r\n}\r\nfunction getStickMagnitude(def, pad) {\r\n    var vAxis = pad.axes[def.verticalAxis.idx];\r\n    var hAxis = pad.axes[def.horizontalAxis.idx];\r\n    var xVal = hAxis.value * def.horizontalAxis.right;\r\n    var yVal = vAxis.value * def.verticalAxis.up * -1;\r\n    var x = Math.sqrt(xVal * xVal + yVal * yVal);\r\n    return clamp(x, 0, 1);\r\n}\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Adapters/Gamepad.ts?");

/***/ }),

/***/ "./src/Adapters/Keyboard.ts":
/*!**********************************!*\
  !*** ./src/Adapters/Keyboard.ts ***!
  \**********************************/
/*! exports provided: Hadoken */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hadoken\", function() { return Hadoken; });\n/* harmony import */ var ph_Hadoken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ph/Hadoken */ \"./src/Hadoken.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n/**\r\n * Hadoken implementation that supports keyboard input.\r\n */\r\nvar Hadoken = /** @class */ (function (_super) {\r\n    __extends(Hadoken, _super);\r\n    function Hadoken(scn, cfg) {\r\n        var _this = _super.call(this, scn, cfg) || this;\r\n        scn.input.keyboard.on('keydown', _this._keydown, _this);\r\n        scn.input.keyboard.on('keyup', _this._keyup, _this);\r\n        return _this;\r\n    }\r\n    Hadoken.prototype._keydown = function (e) {\r\n        // checks for semantic input based on the provided keycode\r\n        var sem = this.hadokenData.config.keymapFn(e.keyCode);\r\n        if (!sem) {\r\n            // if no mapping is found then we don't care about this keypress\r\n            return;\r\n        }\r\n        Object(ph_Hadoken__WEBPACK_IMPORTED_MODULE_0__[\"MaybeAddKey\"])(this.hadokenData, sem, e.timeStamp);\r\n    };\r\n    Hadoken.prototype._keyup = function (e) {\r\n        // checks for semantic input based on the provided keycode\r\n        var sem = this.hadokenData.config.keymapFn(e.keyCode);\r\n        if (!sem) {\r\n            // if no mapping is found then we don't care about this key release\r\n            return;\r\n        }\r\n        Object(ph_Hadoken__WEBPACK_IMPORTED_MODULE_0__[\"MaybeRemoveKey\"])(this.hadokenData, sem);\r\n    };\r\n    return Hadoken;\r\n}(ph_Hadoken__WEBPACK_IMPORTED_MODULE_0__[\"Hadoken\"]));\r\n\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Adapters/Keyboard.ts?");

/***/ }),

/***/ "./src/Common/Filters.ts":
/*!*******************************!*\
  !*** ./src/Common/Filters.ts ***!
  \*******************************/
/*! exports provided: NewChain, CoalesseInputs, OnlyMostRecent, MapToFacing */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NewChain\", function() { return NewChain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CoalesseInputs\", function() { return CoalesseInputs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OnlyMostRecent\", function() { return OnlyMostRecent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapToFacing\", function() { return MapToFacing; });\n/* harmony import */ var ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ph/InputSnapshot */ \"./src/InputSnapshot.ts\");\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\n/**\r\n * Takes a series of filters that should be applied to an input snapshot and\r\n * combines them into a single filter function that passes the result of\r\n * filter[0] into filter[1] etc.\r\n */\r\nfunction NewChain() {\r\n    var filters = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        filters[_i] = arguments[_i];\r\n    }\r\n    return function (input) { return filters.reduce(function (acc, nextFn) { return nextFn(acc); }, input); };\r\n}\r\n/**\r\n * Combines multiple inputs into a single combined direction with a pressed\r\n * timestamp of the most recent input registered, e.g., when both up and right\r\n * are pressed you could replace both with `up+right'.\r\n */\r\nfunction CoalesseInputs(mappings) {\r\n    return function (input) {\r\n        var hasAll = function (set) { return set.every(function (k) { return !!output[k]; }); };\r\n        var output = __assign({}, input.state);\r\n        Object.keys(mappings).forEach(function (k) {\r\n            if (hasAll(mappings[k])) {\r\n                var timeStamp_1 = 0;\r\n                mappings[k].forEach(function (e) {\r\n                    if (output[e].pressed > timeStamp_1) {\r\n                        timeStamp_1 = output[e].pressed;\r\n                    }\r\n                    delete output[e];\r\n                });\r\n                output[k] = { pressed: timeStamp_1 };\r\n            }\r\n        });\r\n        return { timestamp: input.timestamp, state: output };\r\n    };\r\n}\r\n/**\r\n * Of the specified inputs only the most recent will be included in the\r\n * resulting input snapshot, e.g., if you press punch:light and punch:hard\r\n * only the most recent punch will be registered.\r\n */\r\nfunction OnlyMostRecent(inputs) {\r\n    var inputLookup = {};\r\n    inputs.forEach(function (k) { inputLookup[k] = true; });\r\n    return function (input) {\r\n        var output = { timestamp: input.timestamp, state: {} };\r\n        Object.keys(input.state).filter(function (k) { return !inputLookup[k]; }).forEach(function (k) {\r\n            output.state[k] = input.state[k];\r\n        });\r\n        var mostRecent = inputs.reduce(function (acc, cur) {\r\n            if (!input.state[cur]) {\r\n                return acc;\r\n            }\r\n            if (acc === null || acc[1] < input.state[cur].pressed) {\r\n                return [cur, input.state[cur].pressed];\r\n            }\r\n            return acc;\r\n        }, null);\r\n        if (mostRecent !== null) {\r\n            var k = mostRecent[0];\r\n            output.state[k] = input.state[k];\r\n        }\r\n        return output;\r\n    };\r\n}\r\n/**\r\n * Converts fixed direction input into relative direction input based on a\r\n * provided function  that returns whether the character in facing right\r\n * or left.\r\n *\r\n * @param {() => 'right' | 'left'} getFacing A function that returns which\r\n *   direction (right or left) should be considered \"forward\"\r\n */\r\nfunction MapToFacing(getFacing) {\r\n    return function (input) {\r\n        var facing = getFacing();\r\n        var output = __assign({}, input, { state: __assign({}, input.state) });\r\n        if (facing === 'right') {\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'right', 'forward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'down+right', 'down+forward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'up+right', 'up+forward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'left', 'backward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'down+left', 'down+backward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'up+left', 'up+backward');\r\n        }\r\n        else {\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'left', 'forward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'down+left', 'down+forward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'up+left', 'up+forward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'right', 'backward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'down+right', 'down+backward');\r\n            output = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"ReplaceKey\"])(output, 'up+right', 'up+backward');\r\n        }\r\n        return output;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Common/Filters.ts?");

/***/ }),

/***/ "./src/Common/Gamepad.ts":
/*!*******************************!*\
  !*** ./src/Common/Gamepad.ts ***!
  \*******************************/
/*! exports provided: isStandardMapping, mkButtonInput, mkTriggerInput, mkStandardLeftStickInput, mkStandardRightStickInput, mkStandardStickInput, mkStickInput, mkBasicStickDpadMapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStandardMapping\", function() { return isStandardMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkButtonInput\", function() { return mkButtonInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkTriggerInput\", function() { return mkTriggerInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkStandardLeftStickInput\", function() { return mkStandardLeftStickInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkStandardRightStickInput\", function() { return mkStandardRightStickInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkStandardStickInput\", function() { return mkStandardStickInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkStickInput\", function() { return mkStickInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkBasicStickDpadMapper\", function() { return mkBasicStickDpadMapper; });\n// checks to see if the phaser exposed gamepad supports the standard mapping\r\nvar isStandardMapping = function (phaserPad) {\r\n    var pad = phaserPad.pad;\r\n    if (!pad) {\r\n        return null;\r\n    }\r\n    var mapping = pad.mapping;\r\n    if (typeof mapping === 'string') {\r\n        return mapping === 'standard';\r\n    }\r\n    return null;\r\n};\r\n/**\r\n * Produces a definition for one of the buttons on the controller.\r\n *\r\n * @param {number} idx The index in the button array that should be mapped to\r\n *   some input; standard button mappings can be found in StandardButton and\r\n *   related objects.\r\n * @param {string} mapping what does this button mean\r\n */\r\nvar mkButtonInput = function (idx, mapping) { return ({\r\n    type: 'digital',\r\n    idx: idx,\r\n    mapping: mapping,\r\n}); };\r\n/**\r\n * This creates a config object for a a trigger button. Does no validation that\r\n * the button passed in is likely to actually be a trigger.\r\n *\r\n * @param {number} idx the index in the controller's button array that should\r\n *   be mapped to some input; standard indices can be found in StandardButton\r\n *   and related objects.\r\n * @param {string} name the name of this trigger; used to expose the raw value\r\n *   in the AnalogContainer\r\n * @param {Triggermapper} triggerMapper maps from an 0->1 value into some input\r\n * @param {string[]} allMapped all possible values that triggerMapper may\r\n *   produce\r\n */\r\nvar mkTriggerInput = function (idx, name, triggerMapper, allMapped) { return ({\r\n    type: 'trigger',\r\n    idx: idx,\r\n    name: name,\r\n    triggerMapper: triggerMapper,\r\n    allMapped: allMapped,\r\n}); };\r\nvar mkStandardLeftStickInput = function (name, angleMapper, allMapped) { return mkStandardStickInput(name, 'left', angleMapper, allMapped); };\r\nvar mkStandardRightStickInput = function (name, angleMapper, allMapped) { return mkStandardStickInput(name, 'right', angleMapper, allMapped); };\r\n/**\r\n * This produces a definition for one of the two (left/right) 2-axis joysticks\r\n * available on the \"standard\" gamepad. For more information see MDN at\r\n * https://w3c.github.io/gamepad/#remapping\r\n * @param {string} name the name of this stick, used to expose processed\r\n *   snapshot data in the AnalogContainer\r\n * @param { 'left' | 'right' } stick which stick on the \"standard controller\"\r\n *   we're providing a specification for\r\n * @param {StickMapper} angleMapper maps from a stick angle+magnitude into\r\n *   some input\r\n * @param {string[]} allMapped all possible inputs that could be mapped from\r\n *   angleMapper\r\n * @returns {StickDef} a complete definition of a Hadoken Gamepad stick input\r\n */\r\nvar mkStandardStickInput = function (name, stick, angleMapper, allMapped) {\r\n    if (stick === 'left') {\r\n        return mkStickInput(name, 0, 1, 1, -1, angleMapper, allMapped);\r\n    }\r\n    if (stick === 'right') {\r\n        return mkStickInput(name, 2, 1, 3, -1, angleMapper, allMapped);\r\n    }\r\n    throw new Error(name + \": Unsupported stick location \" + stick);\r\n};\r\n/**\r\n * @param {string} name the name of this stick, used to expose processed\r\n *   snapshot data in the AnalogContainer\r\n * @param {number} horizIdx index of the horizontal axis\r\n * @param {1|-1} right is a \"right\" position indicated by 1 or -1\r\n * @param {number} vertIdx index of the vertical axis\r\n * @param {1|-1} up is an \"up\" position indicated by 1 or -1\r\n * @param {StickMapper} angleMapper maps from a stick angle+magnitude into\r\n *   some input\r\n * @param {string[]} allMapped all possible inputs that could be mapped from\r\n *   angleMapper\r\n * @returns {StickDef} a complete definition of a Hadoken Gamepad stick input\r\n */\r\nvar mkStickInput = function (name, horizIdx, right, vertIdx, up, angleMapper, allMapped) { return ({\r\n    type: 'stick',\r\n    name: name,\r\n    verticalAxis: {\r\n        idx: vertIdx,\r\n        up: up,\r\n    },\r\n    horizontalAxis: {\r\n        idx: horizIdx,\r\n        right: right,\r\n    },\r\n    angleMapper: angleMapper,\r\n    allMapped: allMapped,\r\n}); };\r\n/**\r\n * Produces a StickMapper that knows how to slice up a circle into 8 directions\r\n * inputs: right, down+right, down, down+left, left, up+left, up, up+right.\r\n *\r\n * Right begins at 0째 and progresses cockwise, e.g.\r\n *   0째   -> right\r\n *   90째  -> down\r\n *   220째 -> up+lift\r\n *\r\n * @param {number} threshold how far does the stick need to be pushed before it\r\n *   registeres as moving in that direction.\r\n * @param {string} prefix if set this causes all inputs to be prefixed with this\r\n *   argument\r\n */\r\nvar mkBasicStickDpadMapper = function (threshold, prefix) {\r\n    if (threshold === void 0) { threshold = 0.5; }\r\n    if (prefix === void 0) { prefix = ''; }\r\n    return function (angle, value) {\r\n        if (value < threshold) {\r\n            return null;\r\n        }\r\n        if (angle >= 337.5 || angle <= 22.5) {\r\n            return prefix + \"right\";\r\n        }\r\n        if (angle > 22.5 && angle < 67.5) {\r\n            return prefix + \"down+right\";\r\n        }\r\n        if (angle >= 67.5 && angle <= 112.5) {\r\n            return prefix + \"down\";\r\n        }\r\n        if (angle > 112.5 && angle < 157.5) {\r\n            return prefix + \"down+left\";\r\n        }\r\n        if (angle >= 157.5 && angle <= 202.5) {\r\n            return prefix + \"left\";\r\n        }\r\n        if (angle > 202.5 && angle < 247.5) {\r\n            return prefix + \"up+left\";\r\n        }\r\n        if (angle >= 247.5 && angle <= 292.5) {\r\n            return prefix + \"up\";\r\n        }\r\n        if (angle > 292.5 && angle < 337.5) {\r\n            return prefix + \"up+right\";\r\n        }\r\n        return null;\r\n    };\r\n};\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Common/Gamepad.ts?");

/***/ }),

/***/ "./src/Common/Keyboard.ts":
/*!********************************!*\
  !*** ./src/Common/Keyboard.ts ***!
  \********************************/
/*! exports provided: NewSimpleMapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NewSimpleMapper\", function() { return NewSimpleMapper; });\n/**\r\n * Constructs a simple translation function between a keyboard input keycode\r\n * to some input that has meaning in your game.\r\n *\r\n * If an input is not present in `map` then it won't be tracked\r\n */\r\nfunction NewSimpleMapper(map) {\r\n    return function (keycode) {\r\n        return map[keycode] || null;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Common/Keyboard.ts?");

/***/ }),

/***/ "./src/Common/Matchers.ts":
/*!********************************!*\
  !*** ./src/Common/Matchers.ts ***!
  \********************************/
/*! exports provided: OneWithPrefix, NoneWithPrefix, All */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneWithPrefix\", function() { return OneWithPrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoneWithPrefix\", function() { return NoneWithPrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"All\", function() { return All; });\n/* harmony import */ var ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ph/InputSnapshot */ \"./src/InputSnapshot.ts\");\n\r\n// Checks to see of there is exactly one input with a given prefix\r\nfunction OneWithPrefix(n) {\r\n    return function (ss, idx) {\r\n        var state = ss[idx].state;\r\n        return Object.keys(state).filter(function (i) { return i.indexOf(n) === 0; }).length === 1;\r\n    };\r\n}\r\n// Verifies no input is pressed with the given prefix\r\nfunction NoneWithPrefix(n) {\r\n    return function (input, idx) {\r\n        var state = input[idx].state;\r\n        return Object.keys(state).filter(function (i) { return i.indexOf(n) === 0; }).length === 0;\r\n    };\r\n}\r\n// Ensure that all the provided matches return true\r\nfunction All() {\r\n    var matchers = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        matchers[_i] = arguments[_i];\r\n    }\r\n    return function (input, idx) {\r\n        return matchers.reduce(function (acc, cur) {\r\n            if (!acc) {\r\n                return false;\r\n            }\r\n            return typeof cur === 'string'\r\n                ? Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"HasKey\"])(input[idx], cur)\r\n                : cur(input, idx);\r\n        }, true);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Common/Matchers.ts?");

/***/ }),

/***/ "./src/Common/SimpleMatcher.ts":
/*!*************************************!*\
  !*** ./src/Common/SimpleMatcher.ts ***!
  \*************************************/
/*! exports provided: New */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"New\", function() { return New; });\n/* harmony import */ var ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ph/InputSnapshot */ \"./src/InputSnapshot.ts\");\n\r\nfunction singleKeyCheck(ck, history, curIdx) {\r\n    if (typeof ck === 'string') {\r\n        var isLast = curIdx == 0;\r\n        var prev = isLast ? { timestamp: 0, state: {} } : history[curIdx - 1];\r\n        var cur = history[curIdx];\r\n        var keys = Object(ph_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"NewInputs\"])(prev, cur);\r\n        var ckIdx = findIndex(keys, ck);\r\n        return ckIdx !== -1;\r\n    }\r\n    return ck(history, curIdx);\r\n}\r\nfunction findIndex(input, ck) {\r\n    for (var i = 0; i < input.length; i++) {\r\n        if (input[i] == ck) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nvar simpleSubsetMatchOptionsDefault = {\r\n    stepDelay: 250,\r\n    totalDelay: 3000,\r\n};\r\n/**\r\n * Checks if a sequence exists within some historic snapshot.\r\n *\r\n * @param {InputSnapshot[]} history An array of input states ordered oldest to\r\n *   newest\r\n * @param {InputCheck[]} sequence An array of inputs that composes a move\r\n *   sequence; ordered last to first\r\n * @param {number} options.stepDelay How much time can pass between each step\r\n *   of the move sequence\r\n * @param {number} options.totalDelay How much time can pass between the first\r\n *   and last input of the move sequence\r\n * @returns {number[] | null} indexes of the sequence match if one is found,\r\n *   null if no match was found\r\n */\r\nfunction simpleSubsetMatch(history, sequence, options) {\r\n    if (options === void 0) { options = simpleSubsetMatchOptionsDefault; }\r\n    var stepDelay = options.stepDelay, totalDelay = options.totalDelay;\r\n    if (!history || !history.length || !sequence || !sequence.length) {\r\n        return null;\r\n    }\r\n    var ck = sequence[0];\r\n    var historyIdx = history.length - 1;\r\n    var lastInputTS = history[historyIdx].timestamp;\r\n    var prevInputTS = lastInputTS;\r\n    var results = [];\r\n    if (!singleKeyCheck(ck, history, historyIdx)) {\r\n        return null;\r\n    }\r\n    results.push(historyIdx);\r\n    historyIdx--;\r\n    var inTime = true;\r\n    for (var i = 1; inTime && i < sequence.length; i++) {\r\n        ck = sequence[i];\r\n        for (; historyIdx >= 0; historyIdx--) {\r\n            var thisInputTS = history[historyIdx].timestamp;\r\n            var brokeFullInput = lastInputTS - thisInputTS > totalDelay;\r\n            var brokeStepInput = prevInputTS - thisInputTS > stepDelay;\r\n            inTime = !(brokeFullInput || brokeStepInput);\r\n            if (!inTime) {\r\n                break;\r\n            }\r\n            if (singleKeyCheck(ck, history, historyIdx)) {\r\n                results.push(historyIdx);\r\n                prevInputTS = thisInputTS;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return results.length == sequence.length ? results : null;\r\n}\r\n/**\r\n * Constructs a simple subset matcher for a given sequence. The maximum amount\r\n * of delay betwen each input and for the entire sequence. These delay values\r\n * are specified in the options parameter and are specified as a number of\r\n * milliseconds. If no input is provided the defaults are:\r\n *   stepDelay: 250ms\r\n *   totalyDelay: 3000ms\r\n *\r\n * The actual match just looks for the sequence of inputs in the correct order\r\n * regardless of any intervening input states. This means you can match a move\r\n * sequence of \"a, a, b\" with input states of \"a, c, a, b.\"\r\n *\r\n * A sequence step can be either a string, in which case we will look for an\r\n * input state that contains that input, or an InputPredicate. See type docs\r\n * on how that is used.\r\n */\r\nfunction New(sequence, options) {\r\n    if (options === void 0) { options = simpleSubsetMatchOptionsDefault; }\r\n    if (sequence.length === 0) {\r\n        return function () { return [false, null]; };\r\n    }\r\n    var seq = sequence.slice();\r\n    seq.reverse();\r\n    return function (history) {\r\n        var mvIndicies = simpleSubsetMatch(history, seq, options);\r\n        if (mvIndicies !== null) {\r\n            for (var i = mvIndicies.slice(-1)[0]; i < history.length; i++) {\r\n                if (null !== simpleSubsetMatch(history.slice(0, i), seq, options)) {\r\n                    return [false, null];\r\n                }\r\n            }\r\n        }\r\n        return !!mvIndicies\r\n            ? [true, { indicies: mvIndicies.reverse() }]\r\n            : [false, null];\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Common/SimpleMatcher.ts?");

/***/ }),

/***/ "./src/Common/StandardButtons.ts":
/*!***************************************!*\
  !*** ./src/Common/StandardButtons.ts ***!
  \***************************************/
/*! exports provided: Standard360, StandardPS, StandardSNES, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Standard360\", function() { return Standard360; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StandardPS\", function() { return StandardPS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StandardSNES\", function() { return StandardSNES; });\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar StandardButton = {\r\n    LeftDpad: {\r\n        Up: 12,\r\n        Right: 15,\r\n        Down: 13,\r\n        Left: 14,\r\n    },\r\n    RightCluster: {\r\n        Down: 0,\r\n        Right: 1,\r\n        Left: 2,\r\n        Up: 3,\r\n    },\r\n    Left: {\r\n        Trigger: 6,\r\n        Shoulder: 4,\r\n        StickPress: 10,\r\n    },\r\n    Right: {\r\n        Trigger: 7,\r\n        Shoulder: 5,\r\n        StickPress: 11,\r\n    },\r\n    Menu: {\r\n        Select: 8,\r\n        Start: 9,\r\n        Center: 16,\r\n    },\r\n};\r\nvar Standard360 = __assign({}, StandardButton, { RightCluster: {\r\n        A: 0,\r\n        B: 1,\r\n        X: 2,\r\n        Y: 3,\r\n    } });\r\nvar StandardPS = __assign({}, StandardButton, { RightCluster: {\r\n        X: 0,\r\n        Circle: 1,\r\n        Square: 2,\r\n        Triangle: 3,\r\n    } });\r\nvar StandardSNES = __assign({}, StandardButton, { RightCluster: {\r\n        B: 0,\r\n        A: 1,\r\n        Y: 2,\r\n        X: 3,\r\n    } });\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (StandardButton);\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Common/StandardButtons.ts?");

/***/ }),

/***/ "./src/Common/index.ts":
/*!*****************************!*\
  !*** ./src/Common/index.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Filters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filters */ \"./src/Common/Filters.ts\");\n/* harmony import */ var _Gamepad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Gamepad */ \"./src/Common/Gamepad.ts\");\n/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Keyboard */ \"./src/Common/Keyboard.ts\");\n/* harmony import */ var _Matchers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Matchers */ \"./src/Common/Matchers.ts\");\n/* harmony import */ var _SimpleMatcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SimpleMatcher */ \"./src/Common/SimpleMatcher.ts\");\n/* harmony import */ var _StandardButtons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./StandardButtons */ \"./src/Common/StandardButtons.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nvar pkg = {\r\n    Filters: _Filters__WEBPACK_IMPORTED_MODULE_0__,\r\n    Gamepad: _Gamepad__WEBPACK_IMPORTED_MODULE_1__,\r\n    Keyboard: _Keyboard__WEBPACK_IMPORTED_MODULE_2__,\r\n    Matchers: _Matchers__WEBPACK_IMPORTED_MODULE_3__,\r\n    SimpleMatcher: _SimpleMatcher__WEBPACK_IMPORTED_MODULE_4__,\r\n    StandardButtons: _StandardButtons__WEBPACK_IMPORTED_MODULE_5__,\r\n};\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (pkg);\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Common/index.ts?");

/***/ }),

/***/ "./src/Hadoken.ts":
/*!************************!*\
  !*** ./src/Hadoken.ts ***!
  \************************/
/*! exports provided: Events, Hadoken, NewHadoken, MaybeBatchUpdate, MaybeAddKey, MaybeRemoveKey, HadokenPause, HadokenResume, HadokenDataClear, curKeys */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Events\", function() { return Events; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hadoken\", function() { return Hadoken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NewHadoken\", function() { return NewHadoken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaybeBatchUpdate\", function() { return MaybeBatchUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaybeAddKey\", function() { return MaybeAddKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaybeRemoveKey\", function() { return MaybeRemoveKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HadokenPause\", function() { return HadokenPause; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HadokenResume\", function() { return HadokenResume; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HadokenDataClear\", function() { return HadokenDataClear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"curKeys\", function() { return curKeys; });\n/* harmony import */ var _InputSnapshot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InputSnapshot */ \"./src/InputSnapshot.ts\");\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\n// A collection of events that Hadoken will emit\r\nvar Events = {\r\n    // Emited  when input state changes, i.e., when a key is pressed or released.\r\n    // When InputUpdate is emited it will be paired with data of type\r\n    // InputUpdateData.\r\n    InputUpdate: 'inputupdate',\r\n    // Emited when a move is matched against the recent input buffer. When Match\r\n    // is emited it will be paired with data of type MatchData.\r\n    Match: 'match',\r\n};\r\n// TODO: rewrite so that you can use multiple adapters per Hadoken\r\nvar Hadoken = /** @class */ (function () {\r\n    function Hadoken(parent, cfg, sync) {\r\n        if (sync === void 0) { sync = null; }\r\n        this.hadokenData = NewHadoken(parent, cfg, sync);\r\n        this.emitter = this.hadokenData.emitter;\r\n    }\r\n    Hadoken.prototype.pause = function () {\r\n        HadokenPause(this.hadokenData);\r\n    };\r\n    Hadoken.prototype.resume = function () {\r\n        HadokenResume(this.hadokenData);\r\n    };\r\n    Hadoken.prototype.clear = function () {\r\n        HadokenDataClear(this.hadokenData);\r\n    };\r\n    Hadoken.prototype.pressed = function () {\r\n        if (this.hadokenData.processedHistory.length === 0) {\r\n            return [];\r\n        }\r\n        return Object.keys(this.hadokenData.processedHistory.slice(-1)[0].state);\r\n    };\r\n    return Hadoken;\r\n}());\r\n\r\nfunction NewHadoken(scn, cfg, sync) {\r\n    var state = {\r\n        scene: scn,\r\n        config: cfg,\r\n        sync: sync,\r\n        matchedMove: null,\r\n        emitter: new Phaser.Events.EventEmitter(),\r\n        isPaused: false,\r\n        rawHistory: [],\r\n        processedHistory: [],\r\n    };\r\n    scn.events.on('preupdate', mkHadokenUpdate(state));\r\n    return state;\r\n}\r\n/**\r\n * mkHadokenUpdate constructs the function that converts any raw inputs\r\n * collected since the list pass and applies any filters to them. It then\r\n * passes the current buffer of processed inputs through the move macher\r\n * collection.\r\n *\r\n * When a new input is added or removed Hadoken.Events.InputUpdate is emitted.\r\n * When an input update results in a move Hadoken.match Events.Match is emitted.\r\n *\r\n * @param {HadokenData<HadokenPipelineConfig>} ctx a Hadoken context\r\n */\r\nfunction mkHadokenUpdate(ctx) {\r\n    var checkMatch = function (matched, cur) {\r\n        if (matched[0] !== '') {\r\n            return matched;\r\n        }\r\n        var _a = cur.match(ctx.processedHistory), match = _a[0], meta = _a[1];\r\n        return match ? [cur.name, meta] : matched;\r\n    };\r\n    var maybeEmitUpdates = function () {\r\n        if (ctx.processedHistory.length === 0) {\r\n            return;\r\n        }\r\n        var states = ctx.processedHistory.slice(-2);\r\n        var _a = states.length < 2\r\n            ? [{ timestamp: 0, state: {} }, states[0]]\r\n            : states, prev = _a[0], cur = _a[1];\r\n        var newKeys = Object(_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"NewInputs\"])(prev, cur);\r\n        var remKeys = Object(_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"RemovedInputs\"])(prev, cur);\r\n        if (newKeys.length || remKeys.length) {\r\n            ctx.emitter.emit(Events.InputUpdate, {\r\n                add: newKeys,\r\n                removed: remKeys,\r\n            });\r\n        }\r\n    };\r\n    var processMatchResults = function (matchResult) {\r\n        if (matchResult !== null && matchResult[0] !== '') {\r\n            var meta = matchResult[1] ? { meta: matchResult[1] } : null;\r\n            ctx.matchedMove = matchResult[0];\r\n            ctx.emitter.emit(Events.Match, __assign({ name: matchResult[0] }, meta));\r\n        }\r\n    };\r\n    return function () {\r\n        if (ctx.sync) {\r\n            ctx.sync(ctx);\r\n        }\r\n        ctx.matchedMove = null;\r\n        // TODO: if raw history exceeds processed history be > 1 frame it suggests\r\n        // multiple input events within a 1-frame period; should we collapse these\r\n        // into a single processed frame?\r\n        for (var i = ctx.processedHistory.length; i < ctx.rawHistory.length; i++) {\r\n            var state = ctx.rawHistory[i];\r\n            var filters = ctx.config.filters;\r\n            var filtered = filters ? filters(state) : state;\r\n            ctx.processedHistory.push(filtered);\r\n            var matchers = ctx.config.matchers || [];\r\n            if (!ctx.isPaused) {\r\n                maybeEmitUpdates();\r\n                processMatchResults(matchers.reduce(checkMatch, ['', null]));\r\n            }\r\n        }\r\n        maybeCullHistory(ctx);\r\n    };\r\n}\r\n// TODO: history culling isn't well tested yet (both the actual function and\r\n// also the implication that now history may be empty instead of always having\r\n// at lesat one frame)\r\nfunction maybeCullHistory(ctx) {\r\n    var limit = ctx.config.bufferLimit;\r\n    var rhLen = ctx.rawHistory.length;\r\n    if (ctx.config.bufferLimitType === 'depth') {\r\n        var remove = rhLen - limit;\r\n        if (remove > 0) {\r\n            ctx.rawHistory = ctx.rawHistory.slice(remove);\r\n            ctx.processedHistory = ctx.processedHistory.slice(remove);\r\n        }\r\n    }\r\n    else {\r\n        var now = Date.now();\r\n        var marker = 0;\r\n        for (; marker < rhLen; marker++) {\r\n            if (now - ctx.rawHistory[marker].timestamp < limit) {\r\n                break;\r\n            }\r\n        }\r\n        if (marker !== 0) {\r\n            ctx.rawHistory = ctx.rawHistory.slice(marker);\r\n            ctx.processedHistory = ctx.processedHistory.slice(marker);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Processes a new adapter state for potentially several state changes at once.\r\n * This is used so that we can create a new record of change when more than\r\n * one input state has been updated since the last time we were able to check\r\n * the adapter.\r\n *\r\n * A concrete reason we might use this is if we have to poll an adapter for\r\n * input state (e.g. the gamepad) vs listening for adapter events (e.g.\r\n * keyboard).\r\n *\r\n * The hadoken context is mutated as a result of this update\r\n *\r\n * @param {HadokenData<HadokenPipelineConfig>} ctx the underlying data object\r\n *   for Hadoken that is used to track input state; this will be mutated as\r\n *   a result of calling batch update\r\n * @param {SemanticInput[]} keysAdded newly engaged inputs\r\n * @param {SemanticInput[]} keysRemoved things that are no longer being pressed\r\n * @param {number} ts an adapter sourced timestamp to track when this reading\r\n *   was taken\r\n */\r\nfunction MaybeBatchUpdate(ctx, keysAdded, keysRemoved, ts) {\r\n    if (ctx.isPaused) {\r\n        return;\r\n    }\r\n    var now = Date.now();\r\n    var hasHistory = ctx.rawHistory.length > 0;\r\n    var lastState = hasHistory\r\n        ? ctx.rawHistory.slice(-1)[0]\r\n        : { timestamp: now - 1, state: {} };\r\n    var newSnapshot = keysAdded.reduce(function (acc, cur) {\r\n        var _a;\r\n        return ({\r\n            timestamp: acc.timestamp,\r\n            state: __assign((_a = {}, _a[cur] = { pressed: ts }, _a), acc.state)\r\n        });\r\n    }, { timestamp: now, state: __assign({}, lastState.state) });\r\n    keysRemoved.forEach(function (k) {\r\n        // if another source adds a key then go ahead and let that preempt removal\r\n        if (keysAdded.indexOf(k) === -1) {\r\n            delete newSnapshot.state[k];\r\n        }\r\n    });\r\n    if (!Object(_InputSnapshot__WEBPACK_IMPORTED_MODULE_0__[\"HasSameKeys\"])(newSnapshot, lastState)) {\r\n        ctx.rawHistory.push(newSnapshot);\r\n    }\r\n}\r\n/**\r\n * Adds a key to the hadoken context with some timestamp if it was not already\r\n * considered pressed. If the key had already been added and not removed then\r\n * no change is made.\r\n */\r\nfunction MaybeAddKey(ctx, key, ts) {\r\n    MaybeBatchUpdate(ctx, [key], [], ts);\r\n}\r\n/**\r\n * If a key was previously thought to be pressed this will remove it from a\r\n * pressed state in the hadoken context. If the key was not considered pressed\r\n * no change will be made.\r\n */\r\nfunction MaybeRemoveKey(ctx, key) {\r\n    MaybeBatchUpdate(ctx, [], [key], Date.now());\r\n}\r\nfunction HadokenPause(data) {\r\n    data.isPaused = true;\r\n}\r\nfunction HadokenResume(data) {\r\n    data.isPaused = false;\r\n}\r\nfunction HadokenDataClear(data) {\r\n    data.rawHistory = [];\r\n    data.processedHistory = [];\r\n}\r\n/**\r\n * Returns the keys that are pressed in the most recent state.\r\n */\r\nfunction curKeys(ctx, processed) {\r\n    if (processed === void 0) { processed = true; }\r\n    var history = processed ? ctx.processedHistory : ctx.rawHistory;\r\n    return history.length > 0\r\n        ? Object.keys(history.slice(-1)[0].state)\r\n        : [];\r\n}\r\n\n\n//# sourceURL=webpack://Hadoken/./src/Hadoken.ts?");

/***/ }),

/***/ "./src/InputSnapshot.ts":
/*!******************************!*\
  !*** ./src/InputSnapshot.ts ***!
  \******************************/
/*! exports provided: HasKey, ReplaceKey, HasSameKeys, NewInputSnapshot, NewInputs, RemovedInputs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HasKey\", function() { return HasKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReplaceKey\", function() { return ReplaceKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HasSameKeys\", function() { return HasSameKeys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NewInputSnapshot\", function() { return NewInputSnapshot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NewInputs\", function() { return NewInputs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RemovedInputs\", function() { return RemovedInputs; });\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n/**\r\n * Returns true if a snapshot has a given key pressed\r\n */\r\nfunction HasKey(s, key) {\r\n    return !!s.state[key];\r\n}\r\nfunction ReplaceKey(s, oldKey, newKey) {\r\n    var output = { timestamp: s.timestamp, state: __assign({}, s.state) };\r\n    if (!s.state[oldKey]) {\r\n        return output;\r\n    }\r\n    output.state[newKey] = s.state[oldKey];\r\n    delete output.state[oldKey];\r\n    return output;\r\n}\r\nfunction HasSameKeys(ss, other) {\r\n    var state = ss.state;\r\n    var otherState = other.state ? other.state : other;\r\n    var nkeys = Object.keys(state);\r\n    var okeys = Object.keys(otherState);\r\n    return !(nkeys.length !== okeys.length ||\r\n        nkeys.some(function (k) { return okeys.indexOf(k) === -1; }));\r\n}\r\nfunction NewInputSnapshot() {\r\n    return {\r\n        timestamp: Date.now(),\r\n        state: {},\r\n    };\r\n}\r\n// Check `ary` to find which elements are not represented in `vals`\r\nfunction difference(ary, vals) {\r\n    var valMap = vals.reduce(function (acc, cur) {\r\n        var _a;\r\n        return (__assign({}, acc, (_a = {}, _a[cur] = true, _a)));\r\n    }, {});\r\n    var retMap = ary.reduce(function (acc, cur) {\r\n        var _a;\r\n        return !valMap[cur] ? __assign({}, acc, (_a = {}, _a[cur] = true, _a)) : acc;\r\n    }, {});\r\n    return Object.keys(retMap);\r\n}\r\nfunction NewInputs(oldSS, newSS) {\r\n    var oldKeys = Object.keys(oldSS.state);\r\n    var newKeys = Object.keys(newSS.state);\r\n    return difference(newKeys, oldKeys);\r\n}\r\nfunction RemovedInputs(oldSS, newSS) {\r\n    var oldKeys = Object.keys(oldSS.state);\r\n    var newKeys = Object.keys(newSS.state);\r\n    return difference(oldKeys, newKeys);\r\n}\r\n\n\n//# sourceURL=webpack://Hadoken/./src/InputSnapshot.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ph_Adapters_Keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ph/Adapters/Keyboard */ \"./src/Adapters/Keyboard.ts\");\n/* harmony import */ var ph_Adapters_Gamepad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ph/Adapters/Gamepad */ \"./src/Adapters/Gamepad.ts\");\n/* harmony import */ var ph_Common_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ph/Common/index */ \"./src/Common/index.ts\");\n/* harmony import */ var ph_Hadoken__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ph/Hadoken */ \"./src/Hadoken.ts\");\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    Base: ph_Hadoken__WEBPACK_IMPORTED_MODULE_3__,\r\n    Adapters: {\r\n        Gamepad: ph_Adapters_Gamepad__WEBPACK_IMPORTED_MODULE_1__,\r\n        Keyboard: ph_Adapters_Keyboard__WEBPACK_IMPORTED_MODULE_0__,\r\n    },\r\n    Common: ph_Common_index__WEBPACK_IMPORTED_MODULE_2__,\r\n});\r\n\n\n//# sourceURL=webpack://Hadoken/./src/index.ts?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.ts */\"./src/index.ts\");\n\n\n//# sourceURL=webpack://Hadoken/multi_./src/index.ts?");

/***/ })

/******/ });
});